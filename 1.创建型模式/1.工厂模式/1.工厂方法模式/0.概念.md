# 工厂方法模式

## 意图

**工厂方法模式**是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

<img src="/Users/ruichengm/knowledge_repository/design_mode/1.创建型模式/a.assets//image-20240103235016187.png" alt="image-20240103235016187" style="zoom:50%;" />

## 问题

假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 `卡车`的类中。

一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。

<img src="/Users/ruichengm/knowledge_repository/design_mode/1.创建型模式/a.assets//image-20240103235201311.png" alt="image-20240103235201311" style="zoom:50%;" />

如果代码其余部分与现有类已经存在耦合关系， 那么向程序中添加新类其实并没有那么容易。

这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部分代码都与 `卡车`类相关。 在程序中添加 `轮船`类需要修改全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外一种运输方式， 很可能需要再次对这些代码进行大幅修改。

最后， 你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。



##  解决方案

工厂方法模式建议使用特殊的*工厂*方法代替对于对象构造函数的直接调用 （即使用 `new`运算符）。 不用担心， 对象仍将通过 `new`运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。

<img src="/Users/ruichengm/knowledge_repository/design_mode/1.创建型模式/a.assets//image-20240103235631384.png" alt="image-20240103235631384" style="zoom:50%;" />

​																				子类可以修改工厂方法返回的对象类型。

乍看之下， 这种更改可能毫无意义： 我们只是改变了程序中调用构造函数的位置而已。 但是， 仔细想一下， 现在你可以在子类中重写工厂方法， 从而改变其创建产品的类型。

但有一点需要注意:仅当这些产品具有共同的基类或者接口时， 子类才能返回不同类型的产品， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口。

![image-20240103235759105](/Users/ruichengm/knowledge_repository/design_mode/1.创建型模式/a.assets//image-20240103235759105.png)

所有产品都必须使用同一接口。



举例来说，  `卡车`Truck和 `轮船`Ship类都必须实现 `运输`Transport接口， 该接口声明了一个名为 `deliver`交付的方法。 每个类都将以不同的方式实现该方法： 卡车走陆路交付货物， 轮船走海路交付货物。  `陆路运输`Road­Logistics类中的工厂方法返回卡车对象， 而 `海路运输`Sea­Logistics类则返回轮船对象。

![image-20240103235918201](/Users/ruichengm/knowledge_repository/design_mode/1.创建型模式/a.assets//image-20240103235918201.png)

只要产品类实现一个共同的接口， 你就可以将其对象传递给客户代码， 而无需提供额外数据。

调用工厂方法的代码 （通常被称为*客户端*代码） 无需了解不同子类返回实际对象之间的差别。 客户端将所有产品视为抽象的 `运输` 。 客户端知道所有运输对象都提供 `交付`方法， 但是并不关心其具体实现方式。

##  工厂方法模式结构

![image-20240104001502102](/Users/ruichengm/knowledge_repository/design_mode/1.创建型模式/a.assets//image-20240104001502102.png)

## 工厂方法模式适合应用场景

*  当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。

*  工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。

   例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。

*  如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。

*  继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件时， 框架如何辨识出该子类？

  解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。

  让我们看看具体是如何实现的。 假设你使用开源 UI 框架编写自己的应用。 你希望在应用中使用圆形按钮， 但是原框架仅支持矩形按钮。 你可以使用 `圆形按钮`Round­Button子类来继承标准的 `按钮`Button类。 但是， 你需要告诉 `UI框架`UIFramework类使用新的子类按钮代替默认按钮。

  为了实现这个功能， 你可以根据基础框架类开发子类 `圆形按钮 UI`UIWith­Round­Buttons ， 并且重写其 `create­Button`创建按钮方法。 基类中的该方法返回 `按钮`对象， 而你开发的子类返回 `圆形按钮`对象。 现在， 你就可以使用 `圆形按钮 UI`类代替 `UI框架`类。 就是这么简单！

*  如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。

*  在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 你会经常碰到这种资源需求。

  

## 工厂方法模式优缺点

### 优点

* 你可以避免创建者和具体产品之间的紧密耦合。
*  *单一职责原则*。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。
*  *开闭原则*。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。

### 缺点

*  应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。

##  与其他模式的关系

- 在许多设计工作的初期都会使用**工厂方法模式**（较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用**抽象工厂模式**、 [原型模式]或 **生成器模式**（更灵活但更加复杂）。
- **抽象工厂模式**通常基于一组**工厂方法**， 但你也可以使用**原型模式**来生成这些类的方法。
- 你可以同时使用**工厂方法**和**迭代器模式**来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。
- **原型**并不基于继承， 因此没有继承的缺点。 另一方面， *原型*需要对被复制对象进行复杂的初始化。 **工厂方法**基于继承， 但是它不需要初始化步骤。
- **工厂方法**是**模板方法模式**的一种特殊形式。 同时， *工厂方法*可以作为一个大型*模板方法*中的一个步骤。







