## 意图

**抽象工厂模式**是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。

<img src="/Users/ruichengm/knowledge_repository/design_mode/1.创建型模式/a.assets//image-20240104061505659.png" alt="image-20240104061505659" style="zoom:50%;" />

## 问题

假设你正在开发一款家具商店模拟器。 你的代码中包括一些类， 用于表示：

1. 一系列相关产品， 例如 `椅子`Chair 、  `沙发`Sofa和 `咖啡桌`Coffee­Table 。
2. 系列产品的不同变体。 例如， 你可以使用 `现代`Modern 、  `维多利亚`Victorian 、  `装饰风艺术`Art­Deco等风格生成 `椅子` 、  `沙发`和 `咖啡桌` 。

![image-20240122145301195](/Users/ruichengm/knowledge_repository/design_mode/1.创建型模式/1.工厂模式/2.抽象工厂模式/a.assets//image-20240122145301195.png)

你需要设法单独生成每件家具对象， 这样才能确保其风格一致。 如果顾客收到的家具风格不一样， 他们可不会开心。

![image-20240122145326356](/Users/ruichengm/knowledge_repository/design_mode/1.创建型模式/1.工厂模式/2.抽象工厂模式/a.assets//image-20240122145326356.png)

此外， 你也不希望在添加新产品或新风格时修改已有代码。 家具供应商对于产品目录的更新非常频繁， 你不会想在每次更新时都去修改核心代码的。

##  解决方案

首先， 抽象工厂模式建议为系列中的每件产品明确声明接口 （例如椅子、 沙发或咖啡桌）。 然后， 确保所有产品变体都继承这些接口。 例如， 所有风格的椅子都实现 `椅子`接口； 所有风格的咖啡桌都实现 `咖啡桌`接口， 以此类推。

![image-20240122145352972](/Users/ruichengm/knowledge_repository/design_mode/1.创建型模式/1.工厂模式/2.抽象工厂模式/a.assets//image-20240122145352972.png)

接下来， 我们需要声明*抽象工厂*——包含系列中所有产品构造方法的接口。 例如 `create­Chair`创建椅子 、  `create­Sofa`创建沙发和 `create­Coffee­Table`创建咖啡桌 。 这些方法必须返回**抽象**产品类型， 即我们之前抽取的那些接口：  `椅子` ，  `沙发`和 `咖啡桌`等等。

![image-20240122145417570](/Users/ruichengm/knowledge_repository/design_mode/1.创建型模式/1.工厂模式/2.抽象工厂模式/a.assets//image-20240122145417570.png)

那么该如何处理产品变体呢？ 对于系列产品的每个变体， 我们都将基于 `抽象工厂`接口创建不同的工厂类。 每个工厂类都只能返回特定类别的产品， 例如，  `现代家具工厂`Modern­Furniture­Factory只能创建 `现代椅子`Modern­Chair 、  `现代沙发`Modern­Sofa和 `现代咖啡桌`Modern­Coffee­Table对象。

客户端代码可以通过相应的抽象接口调用工厂和产品类。 你无需修改实际客户端代码， 就能更改传递给客户端的工厂类， 也能更改客户端代码接收的产品变体。

![image-20240122145451545](/Users/ruichengm/knowledge_repository/design_mode/1.创建型模式/1.工厂模式/2.抽象工厂模式/a.assets//image-20240122145451545.png)

假设客户端想要工厂创建一把椅子。 客户端无需了解工厂类， 也不用管工厂类创建出的椅子类型。 无论是现代风格， 还是维多利亚风格的椅子， 对于客户端来说没有分别， 它只需调用抽象 `椅子`接口就可以了。 这样一来， 客户端只需知道椅子以某种方式实现了 `sit­On`坐下方法就足够了。 此外， 无论工厂返回的是何种椅子变体， 它都会和由同一工厂对象创建的沙发或咖啡桌风格一致。

最后一点说明： 如果客户端仅接触抽象接口， 那么谁来创建实际的工厂对象呢？ 一般情况下， 应用程序会在初始化阶段创建具体工厂对象。 而在此之前， 应用程序必须根据配置文件或环境设定选择工厂类别。

##  抽象工厂模式结构

![image-20240122145519901](/Users/ruichengm/knowledge_repository/design_mode/1.创建型模式/1.工厂模式/2.抽象工厂模式/a.assets//image-20240122145519901.png)

##  抽象工厂模式适合应用场景

![image-20240122145542700](/Users/ruichengm/knowledge_repository/design_mode/1.创建型模式/1.工厂模式/2.抽象工厂模式/a.assets//image-20240122145542700.png)

##  实现方式

1. 以不同的产品类型与产品变体为维度绘制矩阵。
2. 为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口。
3. 声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法。
4. 为每种产品变体实现一个具体工厂类。
5. 在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对象传递给所有需要创建产品的类。
6. 找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。

##  抽象工厂模式优缺点

![image-20240122145607118](/Users/ruichengm/knowledge_repository/design_mode/1.创建型模式/1.工厂模式/2.抽象工厂模式/a.assets//image-20240122145607118.png)

##  与其他模式的关系

![image-20240122145633422](/Users/ruichengm/knowledge_repository/design_mode/1.创建型模式/1.工厂模式/2.抽象工厂模式/a.assets//image-20240122145633422.png)